---
title: "CPU"
date: "2025-08-20"
thumbnail: "assets/img/thumbnail/cpu.jpg"
---

# 이론
---

Single Cycle
    
    가장 긴 Path를 가진 Type : L-Type (RAM을 거치기 때문에)

    Path가 짧은 R-Type 같은 것들도 다 L-Type의 Clock에 맞춰서 동작을 하게 됨
    -> 비효율적

Multi Cycle

    중간 중간 쪼개서 각각 한 Clock에 동작하게 만듦
    -> Type 마다 서로 다른 Clock에 동작하게 만들 수 있음

    
# 과제 & 코드
---

## C 언어
```
void sort(int *pData, int size);
void swap(int *pA, int *pB);

int main()
{
    int arData[6] = {5, 4, 3, 2, 1};

    sort(arData, 5);

    return 0;
}


void sort(int *pData, int size)
{
    for (int i = 0; i < size; i++)
    {
        for(int j = 0; j < size - i - 1; j++)
        {
            if(pData[j] > pData[j+1])
                swap(&pData[j], &pData[j+1]);
        }
    }
}

void swap(int *pA, int *pB)
{
    int temp;
    temp = *pA;
    *pA = *pB;
    *pB = temp;
}
```

## 어셈블리어
```
main:
        addi    sp,sp,-48
        sw      ra,44(sp)
        sw      s0,40(sp)
        addi    s0,sp,48
        sw      zero,-40(s0)
        sw      zero,-36(s0)
        sw      zero,-32(s0)
        sw      zero,-28(s0)
        sw      zero,-24(s0)
        sw      zero,-20(s0)
        li      a5,5
        sw      a5,-40(s0)
        li      a5,4
        sw      a5,-36(s0)
        li      a5,3
        sw      a5,-32(s0)
        li      a5,2
        sw      a5,-28(s0)
        li      a5,1
        sw      a5,-24(s0)
        addi    a5,s0,-40
        li      a1,5
        mv      a0,a5
        call    sort
        li      a5,0
        mv      a0,a5
        lw      ra,44(sp)
        lw      s0,40(sp)
        addi    sp,sp,48
        jr      ra
sort:
        addi    sp,sp,-48
        sw      ra,44(sp)
        sw      s0,40(sp)
        addi    s0,sp,48
        sw      a0,-36(s0)
        sw      a1,-40(s0)
        sw      zero,-20(s0)
        j       .L4
.L8:
        sw      zero,-24(s0)
        j       .L5
.L7:
        lw      a5,-24(s0)
        slli    a5,a5,2
        lw      a4,-36(s0)
        add     a5,a4,a5
        lw      a4,0(a5)
        lw      a5,-24(s0)
        addi    a5,a5,1
        slli    a5,a5,2
        lw      a3,-36(s0)
        add     a5,a3,a5
        lw      a5,0(a5)
        ble     a4,a5,.L6
        lw      a5,-24(s0)
        slli    a5,a5,2
        lw      a4,-36(s0)
        add     a3,a4,a5
        lw      a5,-24(s0)
        addi    a5,a5,1
        slli    a5,a5,2
        lw      a4,-36(s0)
        add     a5,a4,a5
        mv      a1,a5
        mv      a0,a3
        call    swap
.L6:
        lw      a5,-24(s0)
        addi    a5,a5,1
        sw      a5,-24(s0)
.L5:
        lw      a4,-40(s0)
        lw      a5,-20(s0)
        sub     a5,a4,a5
        addi    a5,a5,-1
        lw      a4,-24(s0)
        blt     a4,a5,.L7
        lw      a5,-20(s0)
        addi    a5,a5,1
        sw      a5,-20(s0)
.L4:
        lw      a4,-20(s0)
        lw      a5,-40(s0)
        blt     a4,a5,.L8
        nop
        nop
        lw      ra,44(sp)
        lw      s0,40(sp)
        addi    sp,sp,48
        jr      ra
swap:
        addi    sp,sp,-48
        sw      ra,44(sp)
        sw      s0,40(sp)
        addi    s0,sp,48
        sw      a0,-36(s0)
        sw      a1,-40(s0)
        lw      a5,-36(s0)
        lw      a5,0(a5)
        sw      a5,-20(s0)
        lw      a5,-40(s0)
        lw      a4,0(a5)
        lw      a5,-36(s0)
        sw      a4,0(a5)
        lw      a5,-40(s0)
        lw      a4,-20(s0)
        sw      a4,0(a5)
        nop
        lw      ra,44(sp)
        lw      s0,40(sp)
        addi    sp,sp,48
        jr      ra
```

## 머신코드
```
04000113
fd010113
02112623
02812423
03010413
fc042c23
fc042e23
fe042023
fe042223
fe042423
fe042623
00500793
fcf42c23
00400793
fcf42e23
00300793
fef42023
00200793
fef42223
00100793
fef42423
fd840793
00500593
00078513
01c000ef
00000793
00078513
02c12083
02812403
03010113
00008067
fd010113
02112623
02812423
03010413
fca42e23
fcb42c23
fe042623
09c0006f
fe042423
0700006f
fe842783
00279793
fdc42703
00f707b3
0007a703
fe842783
00178793
00279793
fdc42683
00f687b3
0007a783
02e7da63
fe842783
00279793
fdc42703
00f706b3
fe842783
00178793
00279793
fdc42703
00f707b3
00078593
00068513
058000ef
fe842783
00178793
fef42423
fd842703
fec42783
40f707b3
fff78793
fe842703
f8f740e3
fec42783
00178793
fef42623
fec42703
fd842783
f6f740e3
00000013
00000013
02c12083
02812403
03010113
00008067
fd010113
02112623
02812423
03010413
fca42e23
fcb42c23
fdc42783
0007a783
fef42623
fd842783
0007a703
fdc42783
00e7a023
fd842783
fec42703
00e7a023
00000013
02c12083
02812403
03010113
00008067
```

## 분석
a0~a7=인자/리턴, ra=복귀주소, sp=스택포인터, s0=프레임포인터
```
main:
    li      sp,0x90              # sp ← 0x90 (특이한 초기화. 실습/베어메탈 환경에서 스택 베이스를 0x40으로 설정)
    addi    sp,sp,-48            # 48바이트 스택 프레임 확보: sp = 0x90 - 48 = 0x60
    sw      ra,44(sp)            # [sp+44]에 ra 저장 (callee-saved 아님이지만 복귀 위해 저장)
    sw      s0,40(sp)            # [sp+40]에 s0 저장
    addi    s0,sp,48             # s0 = sp + 48 → 프레임 포인터 설정 (FP=원래 sp 기준)

    sw      zero,-40(s0)         # arr[0] = 0 초기화
    sw      zero,-36(s0)         # arr[1] = 0 초기화
    sw      zero,-32(s0)         # arr[2] = 0 초기화
    sw      zero,-28(s0)         # arr[3] = 0 초기화
    sw      zero,-24(s0)         # arr[4] = 0 초기화
    sw      zero,-20(s0)         # 로컬 -20(s0) = 0  (여긴 이후에 직접 쓰진 않음)

    li      a5,5
    sw      a5,-40(s0)           # arr[0] = 5
    li      a5,4
    sw      a5,-36(s0)           # arr[1] = 4
    li      a5,3
    sw      a5,-32(s0)           # arr[2] = 3
    li      a5,2
    sw      a5,-28(s0)           # arr[3] = 2
    li      a5,1
    sw      a5,-24(s0)           # arr[4] = 1   → 배열 [5,4,3,2,1] 구성 (내림차순)

    addi    a5,s0,-40            # a5 = &arr[0] (배열 시작 주소)
    li      a1,5                 # a1 = 길이 5
    mv      a0,a5                # a0 = 배열 포인터
    call    sort                 # sort(arr, 5) 호출 (버블정렬)

    li      a5,0
    mv      a0,a5                # 리턴값 a0 = 0 (main의 반환값)
    lw      ra,44(sp)            # 저장했던 ra 복원
    lw      s0,40(sp)            # 저장했던 s0 복원
    addi    sp,sp,48             # 스택 프레임 해제
    jr      ra                   # 호출자 복귀
```

```
sort:
    addi    sp,sp,-48            # 48바이트 스택 프레임
    sw      ra,44(sp)
    sw      s0,40(sp)
    addi    s0,sp,48             # 프레임 포인터 설정

    sw      a0,-36(s0)           # -36(s0) ← 배열 포인터 (arr*)
    sw      a1,-40(s0)           # -40(s0) ← 길이 n
    sw      zero,-20(s0)         # i = 0  (외부 루프 인덱스)

    j       .L4                  # 외부 루프 조건 검사로 점프

.L8:                               # 외부 루프의 각 회차 시작점 (i 고정 후)
    sw      zero,-24(s0)         # j = 0  (내부 루프 인덱스 초기화)
    j       .L5                  # 내부 루프 조건 검사로 점프

.L7:                               # 내부 루프 본문: arr[j]와 arr[j+1] 비교
    lw      a5,-24(s0)           # a5 = j
    slli    a5,a5,2              # 바이트 오프셋 = j*4
    lw      a4,-36(s0)           # a4 = arr(base)
    add     a5,a4,a5             # a5 = &arr[j]
    lw      a4,0(a5)             # a4 = arr[j]

    lw      a5,-24(s0)           # a5 = j
    addi    a5,a5,1              # a5 = j+1
    slli    a5,a5,2              # (j+1)*4
    lw      a3,-36(s0)           # a3 = arr(base)
    add     a5,a3,a5             # a5 = &arr[j+1]
    lw      a5,0(a5)             # a5 = arr[j+1]

    ble     a4,a5,.L6            # if (arr[j] <= arr[j+1]) 스왑 생략 → .L6

    # 여기 오면 arr[j] > arr[j+1] → swap(&arr[j], &arr[j+1])
    lw      a5,-24(s0)           # a5 = j
    slli    a5,a5,2              # j*4
    lw      a4,-36(s0)           # a4 = arr(base)
    add     a3,a4,a5             # a3 = &arr[j]

    lw      a5,-24(s0)           # a5 = j
    addi    a5,a5,1              # j+1
    slli    a5,a5,2              # (j+1)*4
    lw      a4,-36(s0)           # a4 = arr(base)
    add     a5,a4,a5             # a5 = &arr[j+1]

    mv      a1,a5                # a1 = &arr[j+1]
    mv      a0,a3                # a0 = &arr[j]
    call    swap                 # swap(&arr[j], &arr[j+1])

.L6:
    lw      a5,-24(s0)           # j++
    addi    a5,a5,1
    sw      a5,-24(s0)

.L5:                               # 내부 루프 조건: j < (n - i - 1)
    lw      a4,-40(s0)           # a4 = n
    lw      a5,-20(s0)           # a5 = i
    sub     a5,a4,a5             # a5 = n - i
    addi    a5,a5,-1             # a5 = n - i - 1
    lw      a4,-24(s0)           # a4 = j
    blt     a4,a5,.L7            # if (j < n-i-1) 본문으로

    lw      a5,-20(s0)           # i++
    addi    a5,a5,1
    sw      a5,-20(s0)

.L4:                               # 외부 루프 조건: i < n
    lw      a4,-20(s0)           # a4 = i
    lw      a5,-40(s0)           # a5 = n
    blt     a4,a5,.L8            # if (i < n) 내부 루프 시작

    nop
    nop
    lw      ra,44(sp)            # 에필로그: 레지스터 복원
    lw      s0,40(sp)
    addi    sp,sp,48             # 스택 해제
    jr      ra                   # 반환
```

```
swap:
    addi    sp,sp,-48            # 스택 프레임 48B
    sw      ra,44(sp)
    sw      s0,40(sp)
    addi    s0,sp,48

    sw      a0,-36(s0)           # -36(s0) = p (첫 번째 주소)
    sw      a1,-40(s0)           # -40(s0) = q (두 번째 주소)

    lw      a5,-36(s0)
    lw      a5,0(a5)             # a5 = *p
    sw      a5,-20(s0)           # temp = *p

    lw      a5,-40(s0)
    lw      a4,0(a5)             # a4 = *q
    lw      a5,-36(s0)
    sw      a4,0(a5)             # *p = *q

    lw      a5,-40(s0)
    lw      a4,-20(s0)           # a4 = temp
    sw      a4,0(a5)             # *q = temp

    nop
    lw      ra,44(sp)
    lw      s0,40(sp)
    addi    sp,sp,48
    jr      ra                   # 반환
```
| 명령어 | 의미 | 예시 |
|--------|------|------|
| `li rd, imm` | rd ← imm (즉시값 로드)<br>사실상 `addi rd, x0, imm`과 동일 | `li sp, 0x90` → sp ← 0x90 (스택 시작 위치 설정) |
| `addi rd, rs1, imm` | rd ← rs1 + imm<br>(imm 범위: -2048 ~ +2047) | `addi sp, sp, -48` → sp ← sp - 48 (스택 프레임 확보)<br>`addi s0, sp, 48` → s0 ← sp + 48 (프레임 포인터 설정) |
| `sw rs2, offset(rs1)` | 메모리[rs1 + offset] ← rs2 (32비트 저장) | `sw ra, 44(sp)` → [sp+44] ← ra (복귀 주소 저장)<br>`sw a5, -40(s0)` → [s0-40] ← a5 (예: arr[0] = 5) |
| `lw rd, offset(rs1)` | rd ← 메모리[rs1 + offset] (32비트 읽기) | `lw a5, -36(s0)` → a5 ← arr[1]<br>`lw ra, 44(sp)` → 스택에 저장한 ra 복원 |
| `mv rd, rs1` | rd ← rs1<br>(사실상 `addi rd, rs1, 0`) | `mv a0, a5` → a0 ← a5 (함수 인자 전달) |
| `call label` | PC+4를 ra에 저장 후 label로 점프<br>(내부적으로 `auipc + jalr`) | `call sort` → ra ← 복귀 주소 저장, sort 함수 실행 |
| `jr rs1` | PC ← rs1<br>(보통 `jr ra`는 return 의미) | `jr ra` → 호출자 함수로 복귀 |
| `ble rs1, rs2, label` | if (rs1 ≤ rs2) goto label | `ble a4, a5, .L6` → if (a4 ≤ a5) then jump `.L6` |
| `blt rs1, rs2, label` | if (rs1 < rs2) goto label | (배열 비교 시 사용: arr[j] < arr[j+1]) |