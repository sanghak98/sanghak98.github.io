---
title: "CPU"
date: "2025-08-19"
thumbnail: "assets/img/thumbnail/cpu.jpg"
---

# 이론
---

## SLTI vs SLTIU

    SLTI는 부호가 있기 때문에 최상위 비트 [31]로 extend

    SLTIU는 부호가 없기 때문에 0으로 extend

![alt text](<../../../assets/img/vlsi2/250819/스크린샷 2025-08-20 100603.png>)

## B-Type

    Program Counter 영향
    
    비교기
    -> if / for / while / switch case ...

    비교해서 점프
    -> 명령어의 주소를 바꾸겠다
    -> 기존에는 rom[0] 부터 순서대로 실행
    -> branch가 중간에 있으면 rom[3] -> rom[7] 가능
    

![alt text](<../../../assets/img/vlsi2/250819/스크린샷 2025-08-20 100612.png>)

![alt text](<../../../assets/img/vlsi2/250819/스크린샷 2025-08-20 100622.png>)

## imm[12][10:5] / imm[4:1][11] 이렇게 생긴 이유
    
    31번에 12번 비트를 얹고 나서 생각해보니까 그 뒤에 값들을 어떻게 써야될지 고민

    만약 12 뒤에 11 10 9 8 이렇게 이어서 쓰면 다른 Type들과 30번 이전 비트가 다르게 생김

    ex) S-Type 12 11 10 9 8 7 6 ...
    ex) N-Type 11 10  9 8 7 6 5 ... 

    따라서 똑같이 유지해주기 위해서 30 ~ 25번 비트에 10 ~ 5번 비트를 얹고 남은 11번 비트는 7번 비트에 얹고 0번 비트를 뺌

    ex) S-Type 12 10 9 8 7 6 5 ...
    ex) N-Type 11 10 9 8 7 6 5 ... 

    이렇게 바꿔서 서로 다른 Type들이라도 Imm의 공통 bit를 최대한 똑같은 위치에 맞춘다.
    -> H/W 최적화에 도움이 된다.

    B,J-Type의 경우 Imm 값이 ROM(PC)주소의 offset 값이 된다
    -> ROM의 주소는 항상 짝수가 되므로 imm[0]의 값은 항상 0이 된다.
    -> imm[0]이 없이 강제로 0을 넣어줘도 된다.
    -> offset 범위 값을 넓힐 수 있다.

# 과제 & 코드
---
